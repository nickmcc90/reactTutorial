<Timestamp: 8:52.>


--Why React?--
1. The way that it uses its virtual DOM is more efficient than vanilla JS.
2. Reusable and clearer web components.
3. It's maintained by facebook, so people are constantly looking after it.
4. React is very hirable.

React is a large framework, and you may not want to use it and download all its
libraries if you are doing a small project.

--ReactDOM & JSX--
JSX is a javascript rendition of HTML. We need to import React from "react" because this
enables JSX to be usable.

** One way to set up React in a project is to have 3 script tags in the header (they 
are in the index.html, so we can just copy these) 

    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

and a type='text/babel' in the script
tag that is in the body that has src='index.js'. Then we go into the index.js and do
the:
ReactDOM.render(<h1>hello world</h1>, document.getElementById("root")); 
of course having a div in our index.html with the id of root.

**^^^ The above way is the easy way to put react in, not the correct way.

Here is the long way to create an element and have it go to the html page using JS:

const h1 = document.createElement("h1")
h1.textContent = "This is an imperative way to program"    // this is used rather than .innerHTML
h1.className = "header"
document.getElementById("root").append(h1)

These lines of code are what we would write if we didn't have react. React allows us to
write these same four lines of code by using JSX like in line 21. Or like this: 

ReactDOM.render(<h1 className="header">Hello, React!</h1>, document.getElementById("root"));

Remember, we must wrap all JSX that is going into the ReactDOM line into one element. This could
just be wrapping everything into one neat div.

***Correct way is to just type the command found in the other tutorial into the terminal...
Type this into the terminal:
  npm create vite@latest 'project-name' -- --template react
This command created this folder, and a few files to start with. We have TailwindCSS in this.




----ACTUAL TUTORIAL NOTES, FROM SOFTWARE SATURDAYS------

--Lesson 3: Intermediate. JSX and ReactJS---
JSX is HTML that can be placed in javascript.
JSX syntax lets you create HTML stuff into javascript variables.

To write JSX, just write some HTML and store it into a variable.

const basicJSX = <p>hi</p>

We deploy the JSX into the App.js in the return area like this:
<div>{basicJSX}</div>

To combine JS and HTML in JSX:
let name = "john smith";
const jsExample = <p>Hello {name}!</p>;

Any JS can be put within the curly brackets. Even logic.
Ternary operators are good too.


You can use most HTML attributes in JSX, but the syntax
is a lil diffy.
const classMake = <p className='diffy'>Hmmm</p>;      // this is the only one that's different.
const idMake = <p id='diffy2'>Hmmmmmm</p>;

Styling can be added to JSX as well, same way as we would for normal HTML.
Make sure to put the file into the src folder and have an import statement
in the index.js top line.
'./index.css';


We can make custom JSX.
If we have a group of tags we want to use over and over, we can
make a custom HTML tag with JSX.
This allows us to reuse JSX and HTML tags. (This is called a component basically)

It's good practice to have these custom tags in different files,
but you can group them in the same file.

**Look at component.js for details.

<46:22, we boutta make our own component 2/27>

**For some reason, I can't get the component code to be in a tag. Only a function call. Weird.


--Lesson 4: More ReactJS--

I downloaded the entire 2023-Spring-ReactJS folder. They made the repository with each
branch being a different lesson, and when you want to see certain lessons you checkout
that lesson. SO SICK.

<13:52 Timestamp>

ReactJS is a front-end JS framework, and it's purpose is so that when you make something,
it doesn't have to all be JS where you are linking elements to javascript all the time.

The main file (usually index.js) needs a ReactDOM.render() to work, which tells React to render
components.

All react components need a return function.

By convention, all the code you want goes inside App.js, which could all be calls to components.
Code goes into the component files too. We never modify index.js.
Also, all custom components go in a component folder.

It is possible to you ReactJS without JSX, but it is very unpopular.
The code for the React component can modify the web page depending on
the props given to it.

PROPS 
Props are a way to pass data from a parent component to a child component.
Props can only be changed by the parent component.
Props can be accessed from the parameters of the function component (child).
We pass in props with the same syntax as html attributes. Ex: style='yes'.

**
make sure there is a node modules folder in the project. To do this, do 
  npm i 
instead of npm start to get the folder (i think. for this I just copied a folder I already had).
**

BACK TO PROPS
We can access props from function components by saying props.'whatever'
'whatever' is whatever the parent function assigns a value to in the App.js.
Let's show an example.

APP.JS (Let's say we have a component called Purdue)
<Purdue year={2024} />

PURDUE.JS
export function Purdue() {
  props.year      <----- This is how we access the prop passed from the parent (App.js)
}

<Timestamp: 30:32>

For this example, go to checkpoint4 I learned that we can make two components, then put them
inside another component. Then put that final component into App.js.

Like a header and info tag into a card tag, and then the card tag put into the app.js. Anything that can be repeated should
be its own component such that it can be reused again and again.


REACTJS HOOKS
This replaces the old class based component methodology.
Hooks give us a way to "hook" into the state and lifecycle of a component.

Our first hook: useState()
Sets the state and creates a function to update the state for a variable.
When the state of the variable is updated using its set function, that change
is reflected anywhere the variable is referenced.

>>import { useState } from "react";
>>const [var, setVar] = useState(initialValue);

Another hook: useEffect()
As a teaser trailer to what this hook does, it allows whatever's inside it to only run once
when the webpage is rendered.

<timestamp: 55:03 We are going to explain how the button shows "hide" and "show" with the toggling
and the states. Then we can continue with the video.>

We use setState() to initially set the value of showDemo1 to false. Then, we have an arrow function
that we call when we click the button to change the value of showDemo1. It uses the setShowDemo1 to
the opposite of what it is, which now will be true. When the value is true, the button will say
"hide" because the contents will be displayed. 
The button controls the value of showDemo1, so we can have an JSX element that is underneath the
button that only appears when the button is toggled. We do this by having a ternary operation in 
the JSX element. If the button makes the value true, we display the components. If it is not true,
we make the contents null, which makes them disappear.
The button and the JSX are encapsulated in a overarching div called with an id of 'demo1'.

Back to the video:
In some practice, I passed a prop to a component.
We passed in a timestamp to the info component from the card component.

To add user interactivity to a button, we add the onClick attribute. I wonder if there's a way
to .addEventListener in a component that takes a class from the button we want.

Here is an example of an onclick with the use of useState():

REMEMBER, THE SETTER VARIABLE GETS CHANGED WITH (), NOT EQUALS SIGN!!!!

const [count, setCount] = useState(0);

const clicked = () => {
  setCount(count + 1)
}

<button onClick={ clicked }>{ count }</button>


Our next task is to do what he said before 1:20:42, which is:
{
Populate the header and info to make the card full. Put an update
button to update the timestamp in the card.
}

For some reason my update button isn't working in the function.
Figure out why next time.


---Lesson 5: APIs and ReactJS---
<Timestamp: 11:30>

Our next hook: useEffect()
It does something right after a component has loaded and when one of
the specified dependencies is modified.
>> import { useEffect } from 'react'
>> useEffect(effectFunction, dependencies)
Basically everytime a value in dependencies changes, useEffect is triggered and
will run the effectFunction.

**By the way, anyonomous functions are functions without names that we use
inline. We know this already, such as:
array.forEach((value, index) => {
 blah blah blah
})

useEffect will run everytime a component loads or unloads
It seems like it runs the code inside useEffect when something is loaded,
and runs the return statement when something is unloaded.

<timestamp: 21:46>